library(igraph)
#rmat: rating matrix m*n
#usersequence: a list of array such that  userSeq[[i]] contains items that are rated by i-th user 
#       (is generated by makeUserseq function)

#rl: length of recommendation list (NDCG@rl)
#trl : length of traiing profile of each user (i.e. UPL)
#nl:  length of neighborhood size (typically set to 100)
#direc: the direction of check point recorder 
#trdirec: the direction for training file if available 
#first run : a logic variable to indicate if the evaluation should be initialized or it should be continued based on the check point file
#dampingFactor: the damping factor for graph-based similarity measure
#simdirec: the direction to store and read similarity values ( that can be helpful for ....)
#simflag: a logical variable to indicate similarity should be calculated(0) or load from file(1)
#trainflag:a logical variable to indicate training set  should be generated randomly(0) or load from file(1)

rankEvaluation_Yu_IteRank<-function(rmat,userSeq,rl=c(1,3,5,10),trl,direc,firstRun,trainflag=0,damping=0.85,trdirec){
  
  userLength= calUserLength(userSeq);
  NDCG=matrix(0,length(trl),length(rl));  
  count=matrix(0,length(trl),length(rl));
  param=c(1,1,0,0)
  tt=0;
  tt2=0;
  if(firstRun==0){
    direcFile=read.csv(direc)
    direcFile=direcFile[,-1]
    param=as.numeric(direcFile[1,]);          st=2;     end=st+length(trl)-1;
    NDCG=data.matrix(direcFile[st:(end),]);     st=end+1; end=st+length(trl)-1;
    count=data.matrix(direcFile[st:end,]);  
    userLength= calUserLength(userSeq); tt=0;
    tt2=param[4];
  }
  
  for(w in param[1]:length(trl)){            
    j=trl[w]
    t=Yu_prepareData(rmat,j+max(rl),userSeq);
    userSeq=t@us;
    rmat=t@rmat2;

    for(i in param[2]:1){
      #trList and testListindices of user in train and tes
      testSet= 1:nrow(rmat);
      trList=c(1:nrow(rmat));
      tr=trList_random(userSeq,j,testSet); 
      if(trainflag==1){
        x=read.csv(trdirec);x=x[,-1]
        tr=lapply(seq_len(nrow(x)),function(i) as.numeric(x[i,]))
      }
   
      ###**********************************
        trMat=makeTrainMat(tr,rmat);
        l1=makeUserPreferenceNet(rmat,us=userSeq,testSet,tr);
        l2=makePReferenceItemNet(rmat,us=userSeq,testSet,tr);    
        l1=cbind(l1,rep(1,nrow(l1)))
        l2=cbind(l2,rep(1,nrow(l2)))     
        g1<-graph.edgelist(l1[,1:2],directed = F);
        g2<-graph.edgelist(l2[,1:2],directed = F);
        #g2=add.vertices(g2,ncol(rmat)^2+2*ncol(rmat)-vcount(g2))
      for(uid in (param[3]+1):length(testSet)){
        if((uid%%50)==0)
          gc(T);
        tp={};
        for(h in 1:length(tr[[testSet[[uid]]]])){
          tp=c(tp,which(userSeq[[testSet[uid]]]==tr[[uid]][h]))
        }
        ts=userSeq[[testSet[uid]]][-tp];
        
        sh=1;
        
        tt2=tt2+system.time(f<-seprateRanking_ppr(l1,l2,testSet[uid],tr,ts,rmat,2,g1,g2));
        
        for(d in 1:length(rl)){
          topK=rl[d];
          r=order(f,decreasing=T);
          r=intersect(r,ts);
          recomList=r[1:topK];
          count[w,d]=count[w,d]+1;
          NDCG[w,d]=NDCG[w,d]+calNDCG(f[ts],rmat[testSet[uid],ts],topK);
        }
          if(uid%%50==0){        
            print(c(uid,NDCG/count))
            checkRes=rbind(c(w,i,uid,tt2[1]),NDCG,count);
            write.csv(checkRes,direc);
          }
      }
      
      checkRes=rbind(c(w,i,uid,tt2[1]),NDCG,count);
      
      write.csv(checkRes,direc);
      
    }
    print("NDCG")
    print(NDCG/count)
    print(c("tt",tt));
    # prec=prec/(count);    
    # reca=reca/(count);
    # NDCG=NDCG/(count);
    
  }    
  
  ev=setClass("ev",slots=c("NDCGALL","count","t1"));
  evt=new("ev",NDCGALL=NDCG/count,count=count,t1=tt2);                        
  return(evt)
}
makeUserPreferenceNet<-function(rmat,us,testSet,tr,perc,map=1:ncol(rmat)){
  print("constructing graph")
  #l=matrix(0,ncol(rmat)^2+nrow(rmat),ncol(rmat)^2+nrow(rmat));
  l=rep(0,2);
  for(i in 1:nrow(rmat)){
    uid=i;
    r=tr[[uid]];
    s=splitRating(rmat,uid,map[r]);
    count=0
    t2=rep(0,2);
    if(i%%1000==0)
      print(i)
    if(length(s)>=2){
      for(j in 1:(length(s)-1)){
        for(k in ((j+1):length(s))){
          #print(c(j,k,length(s)))
          if(length(s[[j]])>0&&length(s[[k]])>0){
            t=tList(i,s[[j]],s[[k]],rmat)
            t2=rbind(t2,t);
            count=count+1;
          }
        }
      }
    }
    if(count>0){
      l=rbind(l,t2[-1,]);
    }
    else{
      dd="(((("
    }
    # print(i)
    
  } 
  return(l[-1,]);
}

makePReferenceItemNet<-function(rmat,us,testSet,tr,perc){
  end=ncol(rmat)*ncol(rmat);
  u=matrix(0,2*ncol(rmat)*ncol(rmat),2)
  rc=1;
  for(k in 1:end){
    q=rep(0,2);
    t=ceiling((k)/ncol(rmat)); #node barande
    t2=(k)%% ncol(rmat);#node bazande 
    if(t2==0)
      t2=ncol(rmat);
    q=rbind(q,c(k,end+2*t-1));
    q=rbind(q,c(k,end+2*t2));    
    u[rc:(rc+1),]=q[-1,];
    rc=rc+2
  }
  print("graph is constructed")
  return(u);
}
seprateRanking_ppr<-function(el1,el2,id,tr,ts,rmat,method=2,g1,g2){
  vc1=nrow(rmat)+ncol(rmat)^2;
  vc2=ncol(rmat)^2+2*ncol(rmat)
  
  g1=add.vertices(g1,vc1-vcount(g1))
  g2=add.vertices(g2,vc2-vcount(g2))
  
 r=rep(0,vc1)
  r[id]=1
  #print("j")
  p=ppr2(el1,personalized =r);
  #p=page.rank(g1,personalized = r)$vector;
  end=ncol(rmat)^2;  
  t=end+nrow(rmat)-vc1
  l=c(p[(nrow(rmat)+1):vc1],rep(0,2*ncol(rmat)+t));
  l=l/sum(l)
  #pref2=ppr(g2,personalized =l)
  #pref=page.rank(g2,personalized = l)$vector
  pref=ppr2(el2,personalized = l/sum(l))
  v1=end+2*(c(1:ncol(rmat)))-1;
  v2=end+2*(c(1:ncol(rmat)));
  l2=pref[v1]/(pref[v1]+pref[v2]);
  return(l2)
}
ppr2<-function(l,personalized){
  #r=get.adjacency(g);
  #e=drop0(r)
  #p=colSums(e);
  nc=length(personalized)
  l2=l;
  l2[,1]=l[,2]
  l2[,2]=l[,1];
  l1=rbind(l,l2)
  #l1=rbind(l1,c(l1[,c(2,1,3)]))
  r=sparseMatrix(i=l1[,1],j=l1[,2],x=rep(1,nrow(l1)),dims = c(nc,nc));
  p=colSums(r);  
  e=crossprod(r,solve(Diagonal(x=p)));
  m=runif(nc,0,1);
  m=personalized;
  m=rep(1/nc,nc)
  m=m/sum(m)
  m=matrix(m,length(m),1)
  #lastt=order(m,decreasing=T)
  er=rep(0,50)
  l=which(personalized!=0)
  for(i in 1:20){  
    m2=0.85*(e%*%m)+0.15*personalized;
    #m2=m2+(1-sum(m2))/length(m2)
    m2=m2/sum(m2)
    m=m2
  }
  return(m)
}
